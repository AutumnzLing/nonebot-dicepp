:py:mod:`DicePP.command.dicepp_command`
=======================================

.. py:module:: DicePP.command.dicepp_command


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   DicePP.command.dicepp_command.UserCommandBase



Functions
~~~~~~~~~

.. autoapisummary::

   DicePP.command.dicepp_command.preprocess_msg
   DicePP.command.dicepp_command.custom_user_command



Attributes
~~~~~~~~~~

.. autoapisummary::

   DicePP.command.dicepp_command.USER_COMMAND_CLS_DICT


.. py:function:: preprocess_msg(msg_str: str) -> str

   预处理消息字符串


.. py:class:: UserCommandBase(bot: bot_core.Bot)

   所有用户指令的基类

   .. py:attribute:: readable_name
      :annotation: :str = 未命名指令

      

   .. py:attribute:: priority
      :annotation: :int

      

   .. py:attribute:: group_only
      :annotation: :bool = False

      

   .. py:attribute:: flag
      :annotation: :int

      

   .. py:attribute:: cluster
      :annotation: :int

      

   .. py:method:: delay_init(self) -> List[str]

      在机器人完成初始化后调用, 此时可以读取本地化文本和配置, 返回提示信息


   .. py:method:: tick(self) -> List[command.bot_command.BotCommandBase]

      每秒调用一次的方法


   .. py:method:: tick_daily(self) -> List[command.bot_command.BotCommandBase]

      每天调用一次


   .. py:method:: can_process_msg(self, msg_str: str, meta: bot_core.MessageMetaData) -> Tuple[bool, bool, Any]
      :abstractmethod:

      确定一条信息能否被这个Command处理
      Args:
          msg_str: 预处理后的信息字符串
          meta: 消息的元信息, 包括原始信息字符串, 发送者id, bot id等等
      Returns:
          should_proc: 是否可以被处理
          should_pass: 如果可以被处理, 是否继续让该消息给其他命令处理. 若should_proc为False, 则该返回值不会被用到
          hint: 传给process_msg的提示


   .. py:method:: process_msg(self, msg_str: str, meta: bot_core.MessageMetaData, hint: Any) -> List[command.bot_command.BotCommandBase]
      :abstractmethod:

      处理信息的函数
      Args:
          msg_str: 预处理后的信息字符串
          meta: 消息的元信息, 包括原始信息字符串, 发送者id, bot id等等
          hint: 预处理时给出的提示
      Returns:
          bot_commands: 一个bot commands list, 即bot要进行的操作, 比如回复消息等等


   .. py:method:: get_help(self, keyword: str, meta: bot_core.MessageMetaData) -> str
      :abstractmethod:

      返回命令的使用帮助
      Args:
          keyword: 查询关键词
          meta: 消息的元信息, 包括原始信息字符串, 发送者id, bot id等等

      Returns:
          help_str: 帮助字符串, 如果关键词不符合预期, 应该返回空字符串


   .. py:method:: get_description(self) -> str
      :abstractmethod:

      返回命令的简短描述, 尽量不要超过一行



.. py:function:: custom_user_command(readable_name: str, priority: int = DPP_COMMAND_PRIORITY_DEFAULT, group_only: bool = False, flag: int = DPP_COMMAND_FLAG_DEFAULT, cluster: int = DPP_COMMAND_CLUSTER_DEFAULT)

   装饰Command类, 给自定义的Command附加一些参数
   Args:
       readable_name: 可读的名称, 应当为中文
       priority: 优先级, 优先级高的类会先处理指令, 数字越小优先级越高
       group_only: 是否只能在群内使用, 如果为True且在私聊中捕获了对应消息, 则会返回提示
       flag: 标志位, 标志着指令的类型是DND指令, 娱乐指令等等, 主要用于profiler
       cluster: 所属的命令群组, 被用来开关某一组功能


.. py:exception:: CommandError(info: str, to_user: bool = False, to_master: bool = True)

   Bases: :py:obj:`Exception`

   执行命令时产生的异常, 说明操作失败的原因, 应当Command内部使用, 不应该抛给Bot

   .. py:method:: __str__(self)

      Return str(self).



.. py:data:: USER_COMMAND_CLS_DICT
   :annotation: :Dict[str, Type[UserCommandBase]]

   

