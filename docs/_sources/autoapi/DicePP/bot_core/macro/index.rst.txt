:py:mod:`DicePP.bot_core.macro`
===============================

.. py:module:: DicePP.bot_core.macro


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   DicePP.bot_core.macro.BotMacro




Attributes
~~~~~~~~~~

.. autoapisummary::

   DicePP.bot_core.macro.MACRO_COMMAND_SPLIT
   DicePP.bot_core.macro.MACRO_PARSE_LIMIT


.. py:data:: MACRO_COMMAND_SPLIT
   :annotation: = %%

   

.. py:data:: MACRO_PARSE_LIMIT
   :annotation: = 500

   

.. py:class:: BotMacro

   Bases: :py:obj:`data_manager.JsonObject`

   用户自定义的宏, 相当于字符串替换
   宏的定义方法:
       [关键字][参数列表, 形如(参数1,参数2,...), 可选][空格][目标字符串]
       目标字符串中与参数同名的字符串将在使用宏时被替换为给定的参数
       在定义时给定参数就必须在使用时给出, 否则不会被认定为宏
       用{MACRO_COMMAND_SPLIT}来表示指令分隔符, {MACRO_COMMAND_SPLIT}左右的空格和换行将会被忽略
       注意:
           第一个空格的位置非常关键, 用来区分替换前的内容和替换后的内容
           参数名字不要重名, 宏可以嵌套, 但不会处理递归(即不可重入), 先定义的宏会先处理
       示例:
       一颗D20 .rd20
       掷骰两次(表达式,原因) .r 表达式 原因 {MACRO_COMMAND_SPLIT} .r 表达式 原因
   宏的使用方法:
       [关键字][用:分隔给定参数]
       输入: 一颗D20 这是一颗d20  ->  等同于:  .rd20 这是一颗d20
       输入: 掷骰两次:d20+2:某种原因  -> 等同于: 执行指令.r d20+2 某种原因 + 执行指令.r d20+2 某种原因

   .. py:method:: serialize(self) -> str


   .. py:method:: deserialize(self, json_str: str) -> None


   .. py:method:: initialize(self, raw: str, command_split: str)


   .. py:method:: process(self, input_str: str)


   .. py:method:: __repr__(self)



